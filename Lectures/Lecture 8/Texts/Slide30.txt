Because the inverse discrete Fourier transform is so similar to the forward transform, we can design a fast algorithm for it as well. This is called the inverse FFT, or IFFT.

In MATLAB, the fft function computes the forward FFT, and the ifft function computes the inverse FFT. For example, fft of X, N computes an N-point FFT. If the vector X has fewer than N points, it pads with zeros; if it has more, it truncates. The IFFT works the same way, just in reverse.

If we were to implement the Fourier transform exactly as in the mathematical definition, we would do a summation for each frequency index k. Each summation is essentially an inner product — it requires N multiplications and N additions. And we need to do this for each of the N output points. That’s N times N operations — N squared in total.
The FFT and IFFT are like built-in shortcuts. You don’t need to know all the details of how they work to use them — just like you don’t need to know how your phone connects to your friend when you press the call button. You can treat FFT and IFFT as black boxes: you give them the data, and they give you the result quickly and efficiently.

With FFT and IFFT, Fourier analysis becomes practical for real-time work. Once we can efficiently move between the time domain and the frequency domain, we can use this power for many applications — performing convolution, estimating spectra, removing noise, detecting patterns or contours in images, and much more.
