Up to now, we’ve been writing our time samples as t-zero, t-one, t-two, and so on, and our frequency samples as u-zero, u-one, u-two, and so on. But when we work with sampled data, what really matters are the integer positions of these samples.

So, to make things simpler, we’ll label them using integers in square brackets. For example:
f of zero means the value of the function at time sample t-zero.
f of one means the value at time sample t-one.
f of N minus one means the value at the last time sample, t N minus one.
We do the same in the frequency domain:
f-hat of zero means the Fourier transform value at frequency sample u-zero.
f-hat of one is at u-one.
And so on, up to f-hat of N minus one.

With this notation, the discrete Fourier transform reads like this:
f-hat of m  equals the sum from n equals zero to N minus one of f of n, multiplied by e to the power of minus j, two pi, m times n divided by N.
Here, n is the index for time-domain samples, and m is the index for frequency components.
Each term is just the sample value f of n  multiplied by a sinusoidal basis wave at frequency index m. Adding all those terms together gives the strength of that frequency in the signal — that’s our Fourier coefficient.

We can also see this as a matrix multiplication:
The time samples f of zero, f of one, …, f of N minus one form a column vector.
They are multiplied by an N-by-N matrix whose entries are these complex exponentials e to the power of minus j, two pi, m times n divided by N.
The result is another vector containing all the frequency samples f-hat of zero, f-hat of one, …, f-hat of N minus one.
For the first frequency index, m equals zero, every exponential equals one, so the first Fourier coefficient is simply the sum of all the time samples.

Later, we’ll talk about scaling factors to account for the sampling step size, but for now this integer-index form keeps the DFT definition clean and easy to use.
