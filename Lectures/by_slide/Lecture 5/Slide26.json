{
  "lecture": "Lecture 5",
  "slide_id": "Slide26",
  "paths": {
    "image": "G:\\My Drive\\1. Studies\\RPI\\Thesis\\1. Prof Ge Wang\\1. Avatar Project\\Future Directions\\Comparing Models\\Lectures\\Retrieved Data\\Further Work\\MILU23\\Lecture 5\\Images\\Slide26.JPG",
    "text": "G:\\My Drive\\1. Studies\\RPI\\Thesis\\1. Prof Ge Wang\\1. Avatar Project\\Future Directions\\Comparing Models\\Lectures\\Retrieved Data\\Further Work\\MILU23\\Lecture 5\\Texts\\Slide26.txt"
  },
  "models": {
    "llava-hf__llava-onevision-qwen2-7b-ov-hf": {
      "concepts": {
        "source": "G:\\My Drive\\1. Studies\\RPI\\Thesis\\1. Prof Ge Wang\\1. Avatar Project\\Future Directions\\Comparing Models\\Lectures\\Retrieved Data\\Further Work\\MILU23\\Lecture 5\\Outputs\\llava-hf__llava-onevision-qwen2-7b-ov-hf\\concepts\\Slide26.json",
        "parsed": {
          "term": "decomposition",
          "category": "mathematics"
        },
        "raw": "{\"slide_id\": \"Slide26\", \"model\": \"llava-hf/llava-onevision-qwen2-7b-ov-hf\", \"prompt\": \"concepts\", \"raw_output\": \"user \\nSystem:\\nYou are an expert educator in medical imaging. From the following slide text,\\nextract the key technical or scientific concepts that are essential for understanding the topic.\\n\\nUser:\\nSLIDE_TEXT:\\nNow let’s take the next step and define the Fourier series more precisely.\\n\\nTo keep things simple — and without losing any generality — we’ll start with a function defined over the interval from 0 to 1. We call this the unit period. The key assumption here is that the function repeats every unit interval. So if we understand what the function does between 0 and 1, we automatically understand it from 1 to 2, 2 to 3, and even from negative 1 to 0.\\n\\nLater, we’ll generalize to other periods — like from 0 to capital T, or from negative T over 2 to positive T over 2. But for now, let’s build our intuition using this simpler interval.\\n\\nSo, what kinds of functions are we considering here?\\nWe’re working with real-valued functions that are square-integrable — that means when you square the function and integrate it over the interval from 0 to 1, the result is finite. If that integral blows up to infinity, the function is too wild, and we can’t represent it with a Fourier series. But if it’s finite, then the function behaves well enough for our purposes.\\n\\nMathematically, we say such functions belong to the space L square of zero to one — that’s the set of square-integrable functions over the interval from 0 to 1. This is a Hilbert space, meaning we can treat functions like vectors in an infinite-dimensional space.\\nAnd just like vectors have a basis, functions in this space also have an orthonormal basis.\\nWhat does that basis look like?\\n\\nIt turns out the basis consists of the constant function 1, plus an infinite family of sine and cosine functions:\\nSquare root of 2 times cosine of 2 pi n t\\nSquare root of 2 times sine of 2 pi n t\\u000bfor n equals 1, 2, 3, and so on.\\nThe factor of square root 2 ensures that each function has unit length — meaning, its inner product with itself equals 1. That’s what makes the basis orthonormal.\\n\\nSo here’s the big idea:\\nAny square-integrable function over the interval 0 to 1 can be expressed as a sum of these basis functions.\\u000bAnd this sum is called the Fourier series.\\nMathematically, we write:\\nf of t equals a naught over two,\\u000bplus the summation over n of a n times cosine of 2 pi n t,\\u000bplus the summation over n of b n times sine of 2 pi n t.\\n\\nSo, what do all these parts mean?\\nFirst, a naught is called the DC component. It represents the average value of the function over one period.\\nThe a n coefficients are multiplied by cosine terms. These describe the even, symmetric parts of the function.\\nAnd the b n coefficients go with the sine terms. They capture the odd, asymmetric parts of the function.\\nIn essence, what we’re doing is splitting the function into symmetrical and asymmetrical patterns, using sines and cosines as building blocks. This is what makes the Fourier series so elegant — it expresses any periodic function as a mix of smooth, familiar waveforms.\\n\\nNow, each of these coefficients can be computed using inner products, which we'll define using integrals in the next slide.\\nBut conceptually, this is just like decomposing a vector into components — except now we're working with continuous functions in an infinite-dimensional space, using smooth sine and cosine waves as our basis.\\nAnd that’s the beauty of the Fourier series:\\u000bRather than reconstructing a function using spikes or samples, we rebuild it by layering together simple waveforms.\\nThis is the core principle of Fourier analysis:\\u000bBreak down the complex using the simple.\\u000bUse a family of smooth waves to represent arbitrary structure.\\nNext, let’s see how to actually compute those coefficients.\\n\\nSTRICT INSTRUCTIONS:\\n- Return pure JSON only. No prose, no markdown, no code fences.\\n- Each concept must appear verbatim (case-insensitive) in SLIDE_TEXT.\\n- Assign exactly one category from:\\n  software | workflow | mathematics | signal_processing | frequency_domain |\\n  physics | instrumentation | data_processing | reconstruction |\\n  quality_metric | communication | modality | anatomy | algorithm | ai_ml\\n- Category guidance:\\n  * software → programming tools/environments (MATLAB, Octave, MathWorks)\\n  * workflow → procedural/course steps (BUT exclude admin like office hours)\\n  * mathematics / signal_processing / frequency_domain → formulas, transforms, filters, spectra\\n  * physics → energy, radiation, waves, gradients, attenuation\\n  * instrumentation → scanners, detectors, coils, transducers, gantry\\n  * data_processing / reconstruction → corrections, backprojection, iterative, FBP, FFT usage\\n  * quality_metric → SNR, resolution, artifacts, MTF, DQE\\n  * communication → network or data transfer\\n  * modality → CT, MRI, PET, SPECT, Ultrasound (US), Optical/Photoacoustic, etc.\\n  * anatomy → biological structures (organs, tissues, bones, vessels) ONLY\\n  * algorithm → analytical/iterative computational methods\\n  * ai_ml → learning methods (deep learning, CNN, transformer, self-supervised)\\n- Reject filler or administrative text (office hours, emails, rooms, homework logistics).\\n- Output format:\\n{\\n  \\\"concepts\\\": [\\n    {\\\"term\\\": \\\"<exact term from slide>\\\", \\\"category\\\": \\\"<category>\\\"}\\n  ],\\n  \\\"evidence\\\": [\\\"<short supporting phrase from SLIDE_TEXT>\\\"]\\n}\\nassistant\\n```json\\n{\\n  \\\"concepts\\\": [\\n    {\\\"term\\\": \\\"Fourier series\\\", \\\"category\\\": \\\"mathematics\\\"},\\n    {\\\"term\\\": \\\"square-integrable functions\\\", \\\"category\\\": \\\"mathematics\\\"},\\n    {\\\"term\\\": \\\"Hilbert space\\\", \\\"category\\\": \\\"mathematics\\\"},\\n    {\\\"term\\\": \\\"orthonormal basis\\\", \\\"category\\\": \\\"mathematics\\\"},\\n    {\\\"term\\\": \\\"DC component\\\", \\\"category\\\": \\\"mathematics\\\"},\\n    {\\\"term\\\": \\\"a_n coefficients\\\", \\\"category\\\": \\\"mathematics\\\"},\\n    {\\\"term\\\": \\\"b_n coefficients\\\", \\\"category\\\": \\\"mathematics\\\"},\\n    {\\\"term\\\": \\\"sine and cosine functions\\\", \\\"category\\\": \\\"mathematics\\\"},\\n    {\\\"term\\\": \\\"Fourier analysis\\\", \\\"category\\\": \\\"mathematics\\\"},\\n    {\\\"term\\\": \\\"decomposition\\\", \\\"category\\\": \\\"mathematics\\\"}\\n  ],\\n  \\\"evidence\\\": [\\\"Now let’s take the next step and define the Fourier series more precisely.\\\", \\n               \\\"To keep things simple — and without losing any generality — we’ll start with a function defined over the interval from 0 to 1. We call this the unit period.\\\", \\n               \\\"The key assumption here is that the function repeats every unit interval.\\\", \\n               \\\"So\", \"parsed\": {\"term\": \"decomposition\", \"category\": \"mathematics\"}}"
      },
      "triples": {
        "source": "G:\\My Drive\\1. Studies\\RPI\\Thesis\\1. Prof Ge Wang\\1. Avatar Project\\Future Directions\\Comparing Models\\Lectures\\Retrieved Data\\Further Work\\MILU23\\Lecture 5\\Outputs\\llava-hf__llava-onevision-qwen2-7b-ov-hf\\triples\\Slide26.json",
        "parsed": {
          "triples": [
            {
              "s": "Fourier series",
              "p": "represents",
              "o": "square-integrable functions over the interval from 0 to 1",
              "modalities": [
                "text"
              ],
              "confidence": 0.9,
              "evidence": "Any square-integrable function over the interval 0 to 1 can be expressed as a sum of these basis functions."
            }
          ]
        },
        "raw": "{\"slide_id\": \"Slide26\", \"model\": \"llava-hf/llava-onevision-qwen2-7b-ov-hf\", \"prompt\": \"triples\", \"raw_output\": \"user \\nSystem:\\nYou are extracting factual relations from a medical imaging lecture. Use only information grounded in the input SLIDE_TEXT.\\n\\nUser:\\nSLIDE_TEXT:\\nNow let’s take the next step and define the Fourier series more precisely.\\n\\nTo keep things simple — and without losing any generality — we’ll start with a function defined over the interval from 0 to 1. We call this the unit period. The key assumption here is that the function repeats every unit interval. So if we understand what the function does between 0 and 1, we automatically understand it from 1 to 2, 2 to 3, and even from negative 1 to 0.\\n\\nLater, we’ll generalize to other periods — like from 0 to capital T, or from negative T over 2 to positive T over 2. But for now, let’s build our intuition using this simpler interval.\\n\\nSo, what kinds of functions are we considering here?\\nWe’re working with real-valued functions that are square-integrable — that means when you square the function and integrate it over the interval from 0 to 1, the result is finite. If that integral blows up to infinity, the function is too wild, and we can’t represent it with a Fourier series. But if it’s finite, then the function behaves well enough for our purposes.\\n\\nMathematically, we say such functions belong to the space L square of zero to one — that’s the set of square-integrable functions over the interval from 0 to 1. This is a Hilbert space, meaning we can treat functions like vectors in an infinite-dimensional space.\\nAnd just like vectors have a basis, functions in this space also have an orthonormal basis.\\nWhat does that basis look like?\\n\\nIt turns out the basis consists of the constant function 1, plus an infinite family of sine and cosine functions:\\nSquare root of 2 times cosine of 2 pi n t\\nSquare root of 2 times sine of 2 pi n t\\u000bfor n equals 1, 2, 3, and so on.\\nThe factor of square root 2 ensures that each function has unit length — meaning, its inner product with itself equals 1. That’s what makes the basis orthonormal.\\n\\nSo here’s the big idea:\\nAny square-integrable function over the interval 0 to 1 can be expressed as a sum of these basis functions.\\u000bAnd this sum is called the Fourier series.\\nMathematically, we write:\\nf of t equals a naught over two,\\u000bplus the summation over n of a n times cosine of 2 pi n t,\\u000bplus the summation over n of b n times sine of 2 pi n t.\\n\\nSo, what do all these parts mean?\\nFirst, a naught is called the DC component. It represents the average value of the function over one period.\\nThe a n coefficients are multiplied by cosine terms. These describe the even, symmetric parts of the function.\\nAnd the b n coefficients go with the sine terms. They capture the odd, asymmetric parts of the function.\\nIn essence, what we’re doing is splitting the function into symmetrical and asymmetrical patterns, using sines and cosines as building blocks. This is what makes the Fourier series so elegant — it expresses any periodic function as a mix of smooth, familiar waveforms.\\n\\nNow, each of these coefficients can be computed using inner products, which we'll define using integrals in the next slide.\\nBut conceptually, this is just like decomposing a vector into components — except now we're working with continuous functions in an infinite-dimensional space, using smooth sine and cosine waves as our basis.\\nAnd that’s the beauty of the Fourier series:\\u000bRather than reconstructing a function using spikes or samples, we rebuild it by layering together simple waveforms.\\nThis is the core principle of Fourier analysis:\\u000bBreak down the complex using the simple.\\u000bUse a family of smooth waves to represent arbitrary structure.\\nNext, let’s see how to actually compute those coefficients.\\n\\nSTRICT INSTRUCTIONS:\\n- Return JSON only. No prose, no markdown, no code fences.\\n- Output a triple only if both subject and object appear verbatim in SLIDE_TEXT (case-insensitive).\\n- Predicates must be one of: uses | via | represents | depends_on | measures | produces | reconstructs_with.\\n- Add modalities [\\\"text\\\"] by default; add \\\"image\\\" only if the relation is clearly visible without the text.\\n- confidence in [0,1]. Do not invent entities or relations.\\n\\nOUTPUT:\\n{\\n  \\\"triples\\\": [\\n    {\\\"s\\\":\\\"<verbatim subject>\\\", \\\"p\\\":\\\"uses|via|represents|depends_on|measures|produces|reconstructs_with\\\",\\n     \\\"o\\\":\\\"<verbatim object>\\\", \\\"modalities\\\":[\\\"text\\\",\\\"image\\\"], \\\"confidence\\\":0.0, \\\"evidence\\\":\\\"<short quote from SLIDE_TEXT>\\\"}\\n  ]\\n}\\nassistant\\n{\\n  \\\"triples\\\": [\\n    {\\\"s\\\":\\\"Fourier series\\\", \\\"p\\\":\\\"represents\\\",\\n     \\\"o\\\":\\\"square-integrable functions over the interval from 0 to 1\\\", \\\"modalities\\\":[\\\"text\\\"], \\\"confidence\\\":0.9, \\\"evidence\\\":\\\"Any square-integrable function over the interval 0 to 1 can be expressed as a sum of these basis functions.\\\"}\\n  ]\\n}\", \"parsed\": {\"triples\": [{\"s\": \"Fourier series\", \"p\": \"represents\", \"o\": \"square-integrable functions over the interval from 0 to 1\", \"modalities\": [\"text\"], \"confidence\": 0.9, \"evidence\": \"Any square-integrable function over the interval 0 to 1 can be expressed as a sum of these basis functions.\"}]}}"
      }
    },
    "OpenGVLab__InternVL3-14B": {
      "concepts": {
        "source": "G:\\My Drive\\1. Studies\\RPI\\Thesis\\1. Prof Ge Wang\\1. Avatar Project\\Future Directions\\Comparing Models\\Lectures\\Retrieved Data\\Further Work\\MILU23\\Lecture 5\\Outputs\\OpenGVLab__InternVL3-14B\\concepts\\Slide26.json",
        "parsed": null,
        "raw": "{\"slide_id\": \"Slide26\", \"model\": \"OpenGVLab/InternVL3-14B\", \"prompt\": \"concepts\", \"raw_output\": \"\", \"parsed\": null}"
      },
      "triples": {
        "source": "G:\\My Drive\\1. Studies\\RPI\\Thesis\\1. Prof Ge Wang\\1. Avatar Project\\Future Directions\\Comparing Models\\Lectures\\Retrieved Data\\Further Work\\MILU23\\Lecture 5\\Outputs\\OpenGVLab__InternVL3-14B\\triples\\Slide26.json",
        "parsed": null,
        "raw": "{\"slide_id\": \"Slide26\", \"model\": \"OpenGVLab/InternVL3-14B\", \"prompt\": \"triples\", \"raw_output\": \"\", \"parsed\": null}"
      }
    },
    "Qwen__Qwen2-VL-7B-Instruct": {
      "concepts": {
        "source": "G:\\My Drive\\1. Studies\\RPI\\Thesis\\1. Prof Ge Wang\\1. Avatar Project\\Future Directions\\Comparing Models\\Lectures\\Retrieved Data\\Further Work\\MILU23\\Lecture 5\\Outputs\\Qwen__Qwen2-VL-7B-Instruct\\concepts\\Slide26.json",
        "parsed": {
          "term": "frequency domain",
          "category": "signal_processing"
        },
        "raw": "{\"slide_id\": \"Slide26\", \"model\": \"Qwen/Qwen2-VL-7B-Instruct\", \"prompt\": \"concepts\", \"timestamp_utc\": \"2025-11-08T22:14:19.761024+00:00\", \"text_length\": 3528, \"raw_output\": \"system\\nYou are a helpful AI for medical imaging.\\nuser\\nSystem:\\nYou are an expert educator in medical imaging. From the following slide text,\\nextract the key technical or scientific concepts that are essential for understanding the topic.\\n\\nUser:\\nSLIDE_TEXT:\\nNow let’s take the next step and define the Fourier series more precisely.\\n\\nTo keep things simple — and without losing any generality — we’ll start with a function defined over the interval from 0 to 1. We call this the unit period. The key assumption here is that the function repeats every unit interval. So if we understand what the function does between 0 and 1, we automatically understand it from 1 to 2, 2 to 3, and even from negative 1 to 0.\\n\\nLater, we’ll generalize to other periods — like from 0 to capital T, or from negative T over 2 to positive T over 2. But for now, let’s build our intuition using this simpler interval.\\n\\nSo, what kinds of functions are we considering here?\\nWe’re working with real-valued functions that are square-integrable — that means when you square the function and integrate it over the interval from 0 to 1, the result is finite. If that integral blows up to infinity, the function is too wild, and we can’t represent it with a Fourier series. But if it’s finite, then the function behaves well enough for our purposes.\\n\\nMathematically, we say such functions belong to the space L square of zero to one — that’s the set of square-integrable functions over the interval from 0 to 1. This is a Hilbert space, meaning we can treat functions like vectors in an infinite-dimensional space.\\nAnd just like vectors have a basis, functions in this space also have an orthonormal basis.\\nWhat does that basis look like?\\n\\nIt turns out the basis consists of the constant function 1, plus an infinite family of sine and cosine functions:\\nSquare root of 2 times cosine of 2 pi n t\\nSquare root of 2 times sine of 2 pi n t\\u000bfor n equals 1, 2, 3, and so on.\\nThe factor of square root 2 ensures that each function has unit length — meaning, its inner product with itself equals 1. That’s what makes the basis orthonormal.\\n\\nSo here’s the big idea:\\nAny square-integrable function over the interval 0 to 1 can be expressed as a sum of these basis functions.\\u000bAnd this sum is called the Fourier series.\\nMathematically, we write:\\nf of t equals a naught over two,\\u000bplus the summation over n of a n times cosine of 2 pi n t,\\u000bplus the summation over n of b n times sine of 2 pi n t.\\n\\nSo, what do all these parts mean?\\nFirst, a naught is called the DC component. It represents the average value of the function over one period.\\nThe a n coefficients are multiplied by cosine terms. These describe the even, symmetric parts of the function.\\nAnd the b n coefficients go with the sine terms. They capture the odd, asymmetric parts of the function.\\nIn essence, what we’re doing is splitting the function into symmetrical and asymmetrical patterns, using sines and cosines as building blocks. This is what makes the Fourier series so elegant — it expresses any periodic function as a mix of smooth, familiar waveforms.\\n\\nNow, each of these coefficients can be computed using inner products, which we'll define using integrals in the next slide.\\nBut conceptually, this is just like decomposing a vector into components — except now we're working with continuous functions in an infinite-dimensional space, using smooth sine and cosine waves as our basis.\\nAnd that’s the beauty of the Fourier series:\\u000bRather than reconstructing a function using spikes or samples, we rebuild it by layering together simple waveforms.\\nThis is the core principle of Fourier analysis:\\u000bBreak down the complex using the simple.\\u000bUse a family of smooth waves to represent arbitrary structure.\\nNext, let’s see how to actually compute those coefficients.\\n\\nSTRICT INSTRUCTIONS:\\n- Return pure JSON only. No prose, no markdown, no code fences.\\n- Each concept must appear verbatim (case-insensitive) in SLIDE_TEXT.\\n- Assign exactly one category from:\\n  software | workflow | mathematics | signal_processing | frequency_domain |\\n  physics | instrumentation | data_processing | reconstruction |\\n  quality_metric | communication | modality | anatomy | algorithm | ai_ml\\n- Reject filler or administrative text.\\n- Output format:\\n{\\n  \\\"concepts\\\": [\\n    {\\\"term\\\": \\\"<exact term from slide>\\\", \\\"category\\\": \\\"<category>\\\"}\\n  ],\\n  \\\"evidence\\\": [\\\"<short supporting phrase from SLIDE_TEXT>\\\"]\\n}\\n\\nassistant\\n{\\n  \\\"concepts\\\": [\\n    {\\\"term\\\": \\\"Fourier series\\\", \\\"category\\\": \\\"mathematics\\\"},\\n    {\\\"term\\\": \\\"unit period\\\", \\\"category\\\": \\\"mathematics\\\"},\\n    {\\\"term\\\": \\\"square-integrable functions\\\", \\\"category\\\": \\\"mathematics\\\"},\\n    {\\\"term\\\": \\\"Hilbert space\\\", \\\"category\\\": \\\"mathematics\\\"},\\n    {\\\"term\\\": \\\"orthonormal basis\\\", \\\"category\\\": \\\"mathematics\\\"},\\n    {\\\"term\\\": \\\"basis functions\\\", \\\"category\\\": \\\"mathematics\\\"},\\n    {\\\"term\\\": \\\"DC component\\\", \\\"category\\\": \\\"mathematics\\\"},\\n    {\\\"term\\\": \\\"a_n coefficients\\\", \\\"category\\\": \\\"mathematics\\\"},\\n    {\\\"term\\\": \\\"b_n coefficients\\\", \\\"category\\\": \\\"mathematics\\\"},\\n    {\\\"term\\\": \\\"inner products\\\", \\\"category\\\": \\\"mathematics\\\"},\\n    {\\\"term\\\": \\\"Fourier analysis\\\", \\\"category\\\": \\\"mathematics\\\"},\\n    {\\\"term\\\": \\\"smooth waves\\\", \\\"category\\\": \\\"mathematics\\\"},\\n    {\\\"term\\\": \\\"reconstruction\\\", \\\"category\\\": \\\"mathematics\\\"},\\n    {\\\"term\\\": \\\"signal processing\\\", \\\"category\\\": \\\"signal_processing\\\"},\\n    {\\\"term\\\": \\\"frequency domain\\\", \\\"category\\\": \\\"signal_processing\\\"},\\n    {\\\"term\\\": \\\"waveforms\\\", \\\"category\\\": \\\"signal\", \"parsed\": {\"term\": \"frequency domain\", \"category\": \"signal_processing\"}}"
      },
      "triples": {
        "source": "G:\\My Drive\\1. Studies\\RPI\\Thesis\\1. Prof Ge Wang\\1. Avatar Project\\Future Directions\\Comparing Models\\Lectures\\Retrieved Data\\Further Work\\MILU23\\Lecture 5\\Outputs\\Qwen__Qwen2-VL-7B-Instruct\\triples\\Slide26.json",
        "parsed": {
          "triples": [
            {
              "s": "Fourier series",
              "p": "uses",
              "o": "square-integrable functions",
              "modalities": [
                "text"
              ],
              "confidence": 1.0,
              "evidence": "functions in this space can be, in a good sense, expressed as the following summation referred to as the Fourier series."
            }
          ]
        },
        "raw": "{\"slide_id\": \"Slide26\", \"model\": \"Qwen/Qwen2-VL-7B-Instruct\", \"prompt\": \"triples\", \"timestamp_utc\": \"2025-11-08T23:13:03.788271+00:00\", \"text_length\": 3528, \"raw_output\": \"system\\nYou are a helpful AI for medical imaging.\\nuser\\nSystem:\\nYou are extracting factual relations from a medical imaging lecture. Use only information grounded in the input SLIDE_TEXT.\\n\\nUser:\\nSLIDE_TEXT:\\nNow let’s take the next step and define the Fourier series more precisely.\\n\\nTo keep things simple — and without losing any generality — we’ll start with a function defined over the interval from 0 to 1. We call this the unit period. The key assumption here is that the function repeats every unit interval. So if we understand what the function does between 0 and 1, we automatically understand it from 1 to 2, 2 to 3, and even from negative 1 to 0.\\n\\nLater, we’ll generalize to other periods — like from 0 to capital T, or from negative T over 2 to positive T over 2. But for now, let’s build our intuition using this simpler interval.\\n\\nSo, what kinds of functions are we considering here?\\nWe’re working with real-valued functions that are square-integrable — that means when you square the function and integrate it over the interval from 0 to 1, the result is finite. If that integral blows up to infinity, the function is too wild, and we can’t represent it with a Fourier series. But if it’s finite, then the function behaves well enough for our purposes.\\n\\nMathematically, we say such functions belong to the space L square of zero to one — that’s the set of square-integrable functions over the interval from 0 to 1. This is a Hilbert space, meaning we can treat functions like vectors in an infinite-dimensional space.\\nAnd just like vectors have a basis, functions in this space also have an orthonormal basis.\\nWhat does that basis look like?\\n\\nIt turns out the basis consists of the constant function 1, plus an infinite family of sine and cosine functions:\\nSquare root of 2 times cosine of 2 pi n t\\nSquare root of 2 times sine of 2 pi n t\\u000bfor n equals 1, 2, 3, and so on.\\nThe factor of square root 2 ensures that each function has unit length — meaning, its inner product with itself equals 1. That’s what makes the basis orthonormal.\\n\\nSo here’s the big idea:\\nAny square-integrable function over the interval 0 to 1 can be expressed as a sum of these basis functions.\\u000bAnd this sum is called the Fourier series.\\nMathematically, we write:\\nf of t equals a naught over two,\\u000bplus the summation over n of a n times cosine of 2 pi n t,\\u000bplus the summation over n of b n times sine of 2 pi n t.\\n\\nSo, what do all these parts mean?\\nFirst, a naught is called the DC component. It represents the average value of the function over one period.\\nThe a n coefficients are multiplied by cosine terms. These describe the even, symmetric parts of the function.\\nAnd the b n coefficients go with the sine terms. They capture the odd, asymmetric parts of the function.\\nIn essence, what we’re doing is splitting the function into symmetrical and asymmetrical patterns, using sines and cosines as building blocks. This is what makes the Fourier series so elegant — it expresses any periodic function as a mix of smooth, familiar waveforms.\\n\\nNow, each of these coefficients can be computed using inner products, which we'll define using integrals in the next slide.\\nBut conceptually, this is just like decomposing a vector into components — except now we're working with continuous functions in an infinite-dimensional space, using smooth sine and cosine waves as our basis.\\nAnd that’s the beauty of the Fourier series:\\u000bRather than reconstructing a function using spikes or samples, we rebuild it by layering together simple waveforms.\\nThis is the core principle of Fourier analysis:\\u000bBreak down the complex using the simple.\\u000bUse a family of smooth waves to represent arbitrary structure.\\nNext, let’s see how to actually compute those coefficients.\\n\\nSTRICT INSTRUCTIONS:\\n- Return JSON only. No prose, no markdown, no code fences.\\n- Output a triple only if both subject and object appear verbatim in SLIDE_TEXT (case-insensitive).\\n- Predicates must be one of: uses | via | represents | depends_on | measures | produces | reconstructs_with.\\n- Add modalities [\\\"text\\\"] by default; add \\\"image\\\" only if clearly visible without the text.\\n- Confidence in [0,1].\\n\\nOUTPUT:\\n{\\n  \\\"triples\\\": [\\n    {\\\"s\\\":\\\"<verbatim subject>\\\", \\\"p\\\":\\\"uses|via|represents|depends_on|measures|produces|reconstructs_with\\\",\\n     \\\"o\\\":\\\"<verbatim object>\\\", \\\"modalities\\\":[\\\"text\\\",\\\"image\\\"], \\\"confidence\\\":0.0, \\\"evidence\\\":\\\"<short quote from SLIDE_TEXT>\\\"}\\n  ]\\n}\\n\\nassistant\\n{\\n  \\\"triples\\\": [\\n    {\\\"s\\\":\\\"Fourier series\\\", \\\"p\\\":\\\"uses\\\", \\\"o\\\":\\\"square-integrable functions\\\", \\\"modalities\\\":[\\\"text\\\"], \\\"confidence\\\":1.0, \\\"evidence\\\":\\\"functions in this space can be, in a good sense, expressed as the following summation referred to as the Fourier series.\\\"}\\n  ]\\n}\", \"parsed\": {\"triples\": [{\"s\": \"Fourier series\", \"p\": \"uses\", \"o\": \"square-integrable functions\", \"modalities\": [\"text\"], \"confidence\": 1.0, \"evidence\": \"functions in this space can be, in a good sense, expressed as the following summation referred to as the Fourier series.\"}]}}"
      }
    },
    "Qwen__Qwen3-VL-4B-Instruct": {
      "concepts": {
        "source": "G:\\My Drive\\1. Studies\\RPI\\Thesis\\1. Prof Ge Wang\\1. Avatar Project\\Future Directions\\Comparing Models\\Lectures\\Retrieved Data\\Further Work\\MILU23\\Lecture 5\\Outputs\\Qwen__Qwen3-VL-4B-Instruct\\concepts\\Slide26.json",
        "parsed": {
          "term": "aₙ cos(2πnt)",
          "category": "mathematics"
        },
        "raw": "{\"slide_id\": \"Slide26\", \"model\": \"Qwen/Qwen3-VL-4B-Instruct\", \"prompt\": \"concepts\", \"timestamp_utc\": \"2025-11-07T22:50:32.066965+00:00\", \"text_length\": 3528, \"raw_output\": \"system\\nYou are a helpful AI for medical imaging.\\nuser\\nSystem:\\nYou are an expert educator in medical imaging. From the following slide text,\\nextract the key technical or scientific concepts that are essential for understanding the topic.\\n\\nUser:\\nSLIDE_TEXT:\\nNow let’s take the next step and define the Fourier series more precisely.\\n\\nTo keep things simple — and without losing any generality — we’ll start with a function defined over the interval from 0 to 1. We call this the unit period. The key assumption here is that the function repeats every unit interval. So if we understand what the function does between 0 and 1, we automatically understand it from 1 to 2, 2 to 3, and even from negative 1 to 0.\\n\\nLater, we’ll generalize to other periods — like from 0 to capital T, or from negative T over 2 to positive T over 2. But for now, let’s build our intuition using this simpler interval.\\n\\nSo, what kinds of functions are we considering here?\\nWe’re working with real-valued functions that are square-integrable — that means when you square the function and integrate it over the interval from 0 to 1, the result is finite. If that integral blows up to infinity, the function is too wild, and we can’t represent it with a Fourier series. But if it’s finite, then the function behaves well enough for our purposes.\\n\\nMathematically, we say such functions belong to the space L square of zero to one — that’s the set of square-integrable functions over the interval from 0 to 1. This is a Hilbert space, meaning we can treat functions like vectors in an infinite-dimensional space.\\nAnd just like vectors have a basis, functions in this space also have an orthonormal basis.\\nWhat does that basis look like?\\n\\nIt turns out the basis consists of the constant function 1, plus an infinite family of sine and cosine functions:\\nSquare root of 2 times cosine of 2 pi n t\\nSquare root of 2 times sine of 2 pi n t\\u000bfor n equals 1, 2, 3, and so on.\\nThe factor of square root 2 ensures that each function has unit length — meaning, its inner product with itself equals 1. That’s what makes the basis orthonormal.\\n\\nSo here’s the big idea:\\nAny square-integrable function over the interval 0 to 1 can be expressed as a sum of these basis functions.\\u000bAnd this sum is called the Fourier series.\\nMathematically, we write:\\nf of t equals a naught over two,\\u000bplus the summation over n of a n times cosine of 2 pi n t,\\u000bplus the summation over n of b n times sine of 2 pi n t.\\n\\nSo, what do all these parts mean?\\nFirst, a naught is called the DC component. It represents the average value of the function over one period.\\nThe a n coefficients are multiplied by cosine terms. These describe the even, symmetric parts of the function.\\nAnd the b n coefficients go with the sine terms. They capture the odd, asymmetric parts of the function.\\nIn essence, what we’re doing is splitting the function into symmetrical and asymmetrical patterns, using sines and cosines as building blocks. This is what makes the Fourier series so elegant — it expresses any periodic function as a mix of smooth, familiar waveforms.\\n\\nNow, each of these coefficients can be computed using inner products, which we'll define using integrals in the next slide.\\nBut conceptually, this is just like decomposing a vector into components — except now we're working with continuous functions in an infinite-dimensional space, using smooth sine and cosine waves as our basis.\\nAnd that’s the beauty of the Fourier series:\\u000bRather than reconstructing a function using spikes or samples, we rebuild it by layering together simple waveforms.\\nThis is the core principle of Fourier analysis:\\u000bBreak down the complex using the simple.\\u000bUse a family of smooth waves to represent arbitrary structure.\\nNext, let’s see how to actually compute those coefficients.\\n\\nSTRICT INSTRUCTIONS:\\n- Return pure JSON only. No prose, no markdown, no code fences.\\n- Each concept must appear verbatim (case-insensitive) in SLIDE_TEXT.\\n- Assign exactly one category from:\\n  software | workflow | mathematics | signal_processing | frequency_domain |\\n  physics | instrumentation | data_processing | reconstruction |\\n  quality_metric | communication | modality | anatomy | algorithm | ai_ml\\n- Reject filler or administrative text.\\n- Output format:\\n{\\n  \\\"concepts\\\": [\\n    {\\\"term\\\": \\\"<exact term from slide>\\\", \\\"category\\\": \\\"<category>\\\"}\\n  ],\\n  \\\"evidence\\\": [\\\"<short supporting phrase from SLIDE_TEXT>\\\"]\\n}\\n\\nassistant\\n{\\n  \\\"concepts\\\": [\\n    {\\n      \\\"term\\\": \\\"Fourier series\\\",\\n      \\\"category\\\": \\\"signal_processing\\\"\\n    },\\n    {\\n      \\\"term\\\": \\\"unit period\\\",\\n      \\\"category\\\": \\\"signal_processing\\\"\\n    },\\n    {\\n      \\\"term\\\": \\\"square-integrable\\\",\\n      \\\"category\\\": \\\"mathematics\\\"\\n    },\\n    {\\n      \\\"term\\\": \\\"L²([0, 1], R)\\\",\\n      \\\"category\\\": \\\"mathematics\\\"\\n    },\\n    {\\n      \\\"term\\\": \\\"orthonormal basis\\\",\\n      \\\"category\\\": \\\"mathematics\\\"\\n    },\\n    {\\n      \\\"term\\\": \\\"constant function 1\\\",\\n      \\\"category\\\": \\\"mathematics\\\"\\n    },\\n    {\\n      \\\"term\\\": \\\"√2 cos(2πnt)\\\",\\n      \\\"category\\\": \\\"mathematics\\\"\\n    },\\n    {\\n      \\\"term\\\": \\\"√2 sin(2πnt)\\\",\\n      \\\"category\\\": \\\"mathematics\\\"\\n    },\\n    {\\n      \\\"term\\\": \\\"a₀/2\\\",\\n      \\\"category\\\": \\\"mathematics\\\"\\n    },\\n    {\\n      \\\"term\\\": \\\"aₙ cos(2πnt)\\\",\\n      \\\"category\\\": \\\"mathematics\\\"\\n    },\\n    {\\n      \\\"term\\\": \\\"bₙ sin(2πnt)\\\",\", \"parsed\": {\"term\": \"aₙ cos(2πnt)\", \"category\": \"mathematics\"}}"
      },
      "triples": {
        "source": "G:\\My Drive\\1. Studies\\RPI\\Thesis\\1. Prof Ge Wang\\1. Avatar Project\\Future Directions\\Comparing Models\\Lectures\\Retrieved Data\\Further Work\\MILU23\\Lecture 5\\Outputs\\Qwen__Qwen3-VL-4B-Instruct\\triples\\Slide26.json",
        "parsed": {
          "s": "Fourier series",
          "p": "represents",
          "o": "real-valued functions that are square-integrable over [0,1]",
          "modalities": [
            "text"
          ],
          "confidence": 0.95,
          "evidence": [
            "For all real-valued functions that are square-integrable over [0,1], which form the space L²([0,1], R), an orthonormal basis is as follows: ..."
          ]
        },
        "raw": "{\"slide_id\": \"Slide26\", \"model\": \"Qwen/Qwen3-VL-4B-Instruct\", \"prompt\": \"triples\", \"timestamp_utc\": \"2025-11-07T22:57:34.705567+00:00\", \"text_length\": 3528, \"raw_output\": \"system\\nYou are a helpful AI for medical imaging.\\nuser\\nSystem:\\nYou are extracting factual relations from a medical imaging lecture. Use only information grounded in the input SLIDE_TEXT.\\n\\nUser:\\nSLIDE_TEXT:\\nNow let’s take the next step and define the Fourier series more precisely.\\n\\nTo keep things simple — and without losing any generality — we’ll start with a function defined over the interval from 0 to 1. We call this the unit period. The key assumption here is that the function repeats every unit interval. So if we understand what the function does between 0 and 1, we automatically understand it from 1 to 2, 2 to 3, and even from negative 1 to 0.\\n\\nLater, we’ll generalize to other periods — like from 0 to capital T, or from negative T over 2 to positive T over 2. But for now, let’s build our intuition using this simpler interval.\\n\\nSo, what kinds of functions are we considering here?\\nWe’re working with real-valued functions that are square-integrable — that means when you square the function and integrate it over the interval from 0 to 1, the result is finite. If that integral blows up to infinity, the function is too wild, and we can’t represent it with a Fourier series. But if it’s finite, then the function behaves well enough for our purposes.\\n\\nMathematically, we say such functions belong to the space L square of zero to one — that’s the set of square-integrable functions over the interval from 0 to 1. This is a Hilbert space, meaning we can treat functions like vectors in an infinite-dimensional space.\\nAnd just like vectors have a basis, functions in this space also have an orthonormal basis.\\nWhat does that basis look like?\\n\\nIt turns out the basis consists of the constant function 1, plus an infinite family of sine and cosine functions:\\nSquare root of 2 times cosine of 2 pi n t\\nSquare root of 2 times sine of 2 pi n t\\u000bfor n equals 1, 2, 3, and so on.\\nThe factor of square root 2 ensures that each function has unit length — meaning, its inner product with itself equals 1. That’s what makes the basis orthonormal.\\n\\nSo here’s the big idea:\\nAny square-integrable function over the interval 0 to 1 can be expressed as a sum of these basis functions.\\u000bAnd this sum is called the Fourier series.\\nMathematically, we write:\\nf of t equals a naught over two,\\u000bplus the summation over n of a n times cosine of 2 pi n t,\\u000bplus the summation over n of b n times sine of 2 pi n t.\\n\\nSo, what do all these parts mean?\\nFirst, a naught is called the DC component. It represents the average value of the function over one period.\\nThe a n coefficients are multiplied by cosine terms. These describe the even, symmetric parts of the function.\\nAnd the b n coefficients go with the sine terms. They capture the odd, asymmetric parts of the function.\\nIn essence, what we’re doing is splitting the function into symmetrical and asymmetrical patterns, using sines and cosines as building blocks. This is what makes the Fourier series so elegant — it expresses any periodic function as a mix of smooth, familiar waveforms.\\n\\nNow, each of these coefficients can be computed using inner products, which we'll define using integrals in the next slide.\\nBut conceptually, this is just like decomposing a vector into components — except now we're working with continuous functions in an infinite-dimensional space, using smooth sine and cosine waves as our basis.\\nAnd that’s the beauty of the Fourier series:\\u000bRather than reconstructing a function using spikes or samples, we rebuild it by layering together simple waveforms.\\nThis is the core principle of Fourier analysis:\\u000bBreak down the complex using the simple.\\u000bUse a family of smooth waves to represent arbitrary structure.\\nNext, let’s see how to actually compute those coefficients.\\n\\nSTRICT INSTRUCTIONS:\\n- Return JSON only. No prose, no markdown, no code fences.\\n- Output a triple only if both subject and object appear verbatim in SLIDE_TEXT (case-insensitive).\\n- Predicates must be one of: uses | via | represents | depends_on | measures | produces | reconstructs_with.\\n- Add modalities [\\\"text\\\"] by default; add \\\"image\\\" only if clearly visible without the text.\\n- Confidence in [0,1].\\n\\nOUTPUT:\\n{\\n  \\\"triples\\\": [\\n    {\\\"s\\\":\\\"<verbatim subject>\\\", \\\"p\\\":\\\"uses|via|represents|depends_on|measures|produces|reconstructs_with\\\",\\n     \\\"o\\\":\\\"<verbatim object>\\\", \\\"modalities\\\":[\\\"text\\\",\\\"image\\\"], \\\"confidence\\\":0.0, \\\"evidence\\\":\\\"<short quote from SLIDE_TEXT>\\\"}\\n  ]\\n}\\n\\nassistant\\n{\\n  \\\"triples\\\": [\\n    {\\n      \\\"s\\\": \\\"Fourier series\\\",\\n      \\\"p\\\": \\\"reconstructs_with\\\",\\n      \\\"o\\\": \\\"sine and cosine functions\\\",\\n      \\\"modalities\\\": [\\\"text\\\"],\\n      \\\"confidence\\\": 0.95,\\n      \\\"evidence\\\": \\\"Any square-integrable function over the interval 0 to 1 can be expressed as a sum of these basis functions. And this sum is called the Fourier series.\\\"\\n    },\\n    {\\n      \\\"s\\\": \\\"Fourier series\\\",\\n      \\\"p\\\": \\\"represents\\\",\\n      \\\"o\\\": \\\"real-valued functions that are square-integrable over [0,1]\\\",\\n      \\\"modalities\\\": [\\\"text\\\"],\\n      \\\"confidence\\\": 0.95,\\n      \\\"evidence\\\": \\\"For all real-valued functions that are square-integrable over [0,1], which form the space L²([0,1], R), an orthonormal basis is as follows: ...\\\"\\n    },\\n    {\\n      \\\"s\\\": \\\"Fourier series\\\",\\n      \\\"p\\\": \\\"uses\\\",\\n      \\\"o\\\": \\\"constant function 1\\\",\\n      \\\"modalities\\\": [\\\"text\\\"],\\n      \\\"confidence\\\": 0.95,\\n      \\\"evidence\", \"parsed\": {\"s\": \"Fourier series\", \"p\": \"represents\", \"o\": \"real-valued functions that are square-integrable over [0,1]\", \"modalities\": [\"text\"], \"confidence\": 0.95, \"evidence\": [\"For all real-valued functions that are square-integrable over [0,1], which form the space L²([0,1], R), an orthonormal basis is as follows: ...\"]}}"
      }
    }
  }
}